import type { NextRequest } from "next/server";
import { requireRole } from "@/lib/api-auth";
import { errorResponse, successResponse } from "@/lib/api-response";
import {
  calculatePeriodDiscount,
  getApplicableDiscounts,
} from "@/lib/business-logic/discount-processor";
import {
  generateTuitions,
  getRecordCountForFrequency,
} from "@/lib/business-logic/tuition-generator";
import { prisma } from "@/lib/prisma";

export async function POST(request: NextRequest) {
  const auth = await requireRole(request, ["ADMIN"]);
  if (auth instanceof Response) return auth;

  try {
    const body = await request.json();
    const {
      classAcademicId,
      feeAmount,
      paymentFrequency = "MONTHLY",
      periodDiscounts,
      studentNisList,
    } = body;

    if (!classAcademicId) {
      return errorResponse("Class is required", "VALIDATION_ERROR", 400);
    }

    if (!feeAmount || feeAmount <= 0) {
      return errorResponse(
        "Fee amount is required and must be greater than 0",
        "VALIDATION_ERROR",
        400,
      );
    }

    // Get class with academic year
    const classAcademic = await prisma.classAcademic.findUnique({
      where: { id: classAcademicId },
      include: {
        academicYear: true,
      },
    });

    if (!classAcademic) {
      return errorResponse("Class not found", "NOT_FOUND", 404);
    }

    // Get students - either specified ones or all students in the class
    let students;
    if (studentNisList && studentNisList.length > 0) {
      students = await prisma.student.findMany({
        where: { nis: { in: studentNisList } },
        select: { nis: true, startJoinDate: true },
      });
    } else {
      // Get students enrolled in this class
      const studentClasses = await prisma.studentClass.findMany({
        where: { classAcademicId },
        include: {
          student: {
            select: { nis: true, startJoinDate: true },
          },
        },
      });
      students = studentClasses.map((sc) => sc.student);

      // Fallback: if no student classes, get all students
      if (students.length === 0) {
        students = await prisma.student.findMany({
          select: { nis: true, startJoinDate: true },
        });
      }
    }

    if (students.length === 0) {
      return errorResponse(
        "No students found to generate tuitions for",
        "VALIDATION_ERROR",
        400,
      );
    }

    // Generate tuition records using the specified payment frequency
    const tuitionsToCreate = generateTuitions({
      classAcademicId,
      frequency: paymentFrequency,
      feeAmount,
      periodDiscounts,
      students: students.map((s) => ({
        nis: s.nis,
        startJoinDate: s.startJoinDate,
      })),
      academicYear: {
        startDate: classAcademic.academicYear.startDate,
        endDate: classAcademic.academicYear.endDate,
      },
    });

    // Check for existing tuitions to avoid duplicates (using period instead of month)
    const existingTuitions = await prisma.tuition.findMany({
      where: {
        classAcademicId,
        studentNis: { in: students.map((s) => s.nis) },
      },
      select: {
        studentNis: true,
        period: true,
        year: true,
      },
    });

    const existingKeys = new Set(
      existingTuitions.map((t) => `${t.studentNis}-${t.period}-${t.year}`),
    );

    const newTuitions = tuitionsToCreate.filter(
      (t) => !existingKeys.has(`${t.studentNis}-${t.period}-${t.year}`),
    );

    const skippedCount = tuitionsToCreate.length - newTuitions.length;

    // Fetch applicable discounts for this class
    const applicableDiscounts = await getApplicableDiscounts(
      classAcademicId,
      classAcademic.academicYearId,
      prisma,
    );

    // Create new tuitions with discount applied
    if (newTuitions.length > 0) {
      await prisma.tuition.createMany({
        data: newTuitions.map((t) => {
          // Calculate discount for this period
          const { discountAmount, discountId } = calculatePeriodDiscount(
            t.period,
            applicableDiscounts,
            classAcademicId,
          );

          return {
            classAcademicId: t.classAcademicId,
            studentNis: t.studentNis,
            period: t.period,
            month: t.month, // For backward compatibility with MONTHLY frequency
            year: t.year,
            feeAmount: t.feeAmount,
            dueDate: t.dueDate,
            status: t.status,
            discountAmount,
            discountId,
          };
        }),
      });
    }

    // Calculate statistics
    const studentsWithFullYear = students.filter(
      (s) => s.startJoinDate <= classAcademic.academicYear.startDate,
    ).length;
    const studentsWithPartialYear = students.length - studentsWithFullYear;
    const recordsPerStudent = getRecordCountForFrequency(paymentFrequency);

    // Calculate discount summary
    const discountsApplied =
      applicableDiscounts.length > 0
        ? applicableDiscounts.map((d) => ({
            id: d.id,
            name: d.name,
            amount: Number(d.discountAmount),
            targetPeriods: d.targetPeriods,
            scope: d.classAcademicId ? "Class-specific" : "School-wide",
          }))
        : [];

    return successResponse({
      generated: newTuitions.length,
      skipped: skippedCount,
      details: {
        totalStudents: students.length,
        studentsWithFullYear,
        studentsWithPartialYear,
        className: classAcademic.className,
        academicYear: classAcademic.academicYear.year,
        paymentFrequency,
        feeAmount,
        recordsPerStudent,
        discountsApplied,
      },
    });
  } catch (error) {
    console.error("Generate tuitions error:", error);
    return errorResponse("Failed to generate tuitions", "SERVER_ERROR", 500);
  }
}
